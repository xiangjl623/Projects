<data>
    <script src="../../../common/js/vue.js"></script>
    <div id="demo">
		<span>
			watchResult:
			{{ fullName }}
		</span>
		<br/>
		<span>
			computeResult:
			{{ computeFullName }}
		</span>
	</div>
	<script>
	    var vm = new Vue({
		  el: '#demo',
		  data: {
			firstName: 'Foo',
			lastName: 'Bar',
			fullName: 'Foo Bar'
		  },
		  watch: {
			firstName: function (val) {
			  this.fullName = val + ' ' + this.lastName
			},
			lastName: function (val) {
			  this.fullName = this.firstName + ' ' + val
			}
		  },
		  computed: {
			computeFullName: function () {
			  return this.firstName + ' ' + this.lastName
			}
		  }	  
		})
	</script>
</data>

<!-- 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 -->